package com.szss.commons.security.dao;


import com.szss.commons.security.service.UserSecurityService;
import com.szss.commons.security.tokens.RESTAuthenticationToken;
import com.szss.commons.security.tokens.RESTCredentials;
import com.szss.commons.security.utils.Constants;
import com.szss.commons.security.utils.SortCollection;
import org.apache.commons.lang.time.DateUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.AuthenticationCredentialsNotFoundException;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider;
import org.springframework.security.authentication.encoding.PasswordEncoder;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.util.Assert;
import org.springframework.util.NumberUtils;

import java.text.MessageFormat;
import java.util.Date;
import java.util.Map;

public class RESTDaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {

    private static final Logger log = LoggerFactory.getLogger(RESTDaoAuthenticationProvider.class);

    private UserSecurityService userSecurityService;
    private PasswordEncoder passwordEncoder;

    /**
     * This is the method which actually performs the check to see whether the user is indeed the correct user
     *
     * @param userDetails
     * @param authentication
     * @throws org.springframework.security.core.AuthenticationException
     */
    @Override
    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { // here we check if the details provided by the user actually stack up.
        //Get Credentials out of the Token...
        RESTAuthenticationToken token = (RESTAuthenticationToken) authentication;
        if (token != null) {
            if (token.getTimestamp() == null) {
                log.debug("Authentication failed: no timestamp provided");
                throw new BadCredentialsException("no timestamp provided");
            }
            Long timestamp;
            try {
                timestamp = NumberUtils.parseNumber(token.getTimestamp(), Long.class);
            } catch (Exception e) {
                log.debug("Authentication failed: This timestamp is not unix timestamp");
                throw new BadCredentialsException("This timestamp is not unix timestamp");
            }
            Date clientTime = new Date(timestamp * 1000);
            Date endTime = DateUtils.addMinutes(clientTime, Constants.EFFECTIVE_TIME);
            Date currentTime = new Date();
            //用户发起请求时的unix时间戳，本次请求签名的有效时间为该时间戳+10分钟。
            if (endTime.before(currentTime)) {
                log.debug("Authentication failed: this request is timeout");
                throw new BadCredentialsException("this request is timeout");
            }

            if (authentication.getCredentials() == null) {
                log.debug("Authentication failed: no credentials provided");
                throw new BadCredentialsException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
            }

            RESTCredentials restCredentials = (RESTCredentials) authentication.getCredentials();
            log.info("PASSWORD = {}", userDetails.getPassword());

            Map<String, String> param = token.getParam();
            String sourceStr = SortCollection.sort(userDetails.getPassword(), param);

            if (!passwordEncoder.isPasswordValid(restCredentials.getSecureHash(), sourceStr, restCredentials.getRequestSalt())) {
                log.debug("Authentication failed: password does not match stored value");
                throw new BadCredentialsException(messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
            }
        } else {
            throw new AuthenticationCredentialsNotFoundException(MessageFormat.format("Expected Authentication Token object of type {0}, but instead received {1}", RESTAuthenticationToken.class.getSimpleName(), authentication.getClass().getSimpleName()));
        }
    }

    /**
     * @param apiKey         This is the API Key that was generated by the user. I guess you could just use the users's username here, but we
     *                       want something that's a little less "guessable"
     * @param authentication The authentication request, which subclasses <em>may</em> need to perform a binding-based
     *                       retrieval of the <code>UserDetails</code>
     * @return the user information (never <code>null</code> - instead an exception should the thrown)
     * @throws org.springframework.security.core.AuthenticationException if the credentials could not be validated (generally a
     *                                                                   <code>BadCredentialsException</code>, an <code>AuthenticationServiceException</code> or
     *                                                                   <code>UsernameNotFoundException</code>)
     */
    @Override
    protected UserDetails retrieveUser(String apiKey, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        log.info("Loading user by apikey = {}", apiKey);

        UserDetails loadedUser;

        try {
            loadedUser = this.getUserSecurityService().getUserByApiKey(apiKey);

            log.info("Loaded user = {}", loadedUser);

        } catch (UsernameNotFoundException notFound) {
            throw notFound;
        } catch (Exception repositoryProblem) {
            throw new AuthenticationServiceException(repositoryProblem.getMessage(), repositoryProblem);
        }

        if (loadedUser == null) {
            throw new AuthenticationServiceException(
                    "UserSecurityServiceImpl returned null, which is an interface contract violation");
        }
        return loadedUser;
    }

    @Override
    protected void doAfterPropertiesSet() throws Exception {
        Assert.notNull(this.userSecurityService, "A UserSecurityServiceImpl must be set");
        Assert.notNull(this.passwordEncoder, "A PasswordEncoder must be set");
    }


    public UserSecurityService getUserSecurityService() {
        return userSecurityService;
    }

    public void setUserSecurityService(UserSecurityService userSecurityService) {
        this.userSecurityService = userSecurityService;
    }

    public PasswordEncoder getPasswordEncoder() {
        return passwordEncoder;
    }

    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }
}
